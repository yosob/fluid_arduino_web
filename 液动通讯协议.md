# 液动通讯协议

## 硬件描述

有 N 个通道，每个通道有 N 个液泵和 1 个气泵。通道支持同时工作。单个通道内，同一时间只有一个泵能进行工作。

代码实现可以对通道数量和每个通道的液泵数量进行配置。
**当前硬件配置（基于 config.h）：**

- 2 个通道（CH1、CH2）
- 每个通道：1 个气泵 + 2 个液泵
- 每个泵有独立PWM控制（0-255）
- 每个泵有独立使能开关

---

## 通讯协议需要支持的功能

### 1. 通讯基本规则

1. **通讯方式**：上位机发送指令，下位机进行回应，下位机不主动发送数据（除心跳响应外）
2. **通讯接口**：UART 串口
3. **通讯参数**：波特率 115200，8 位数据位，1 位停止位，无校验位
4. **帧格式**：帧头(2B) + 命令(1B) + 长度(1B) + 数据(N B) + 校验(1B)

---

### 2. 设备信息管理

#### 2.1 获取固件版本

- **功能**：上位机能获取下位机的固件版本、硬件版本、硬件名称
- **返回信息**：
  - 硬件版本号（如 1.0）
  - 固件版本号（如 1.0）
  - 硬件名称（如 "fluid V0"）

---

### 3. 状态监控

#### 3.1 获取运行状态

- **功能**：上位机能获取下位机的运行状态
- **返回信息**：
  - 当前工作模式（指令模式/循环模式/停止状态）
  - 所有通道的状态（哪个泵在运行）
  - 每个泵的 PWM 值（0-255）

**注意**：只有泵才有PWM值，通道本身没有PWM或功率值。

---

### 4. 运行控制

#### 4.1 指令模式（Manual Mode）

**工作原理**：

- 发送单条指令，下位机执行，执行完毕后返回结果
- 执行后泵持续工作，直到收到新的控制指令

**支持的指令**：

1. **启动通道泵**

   - 指定通道号（CH1/CH2）
   - 指定泵类型（气泵/液泵 1/液泵 2）
   - 指定PWM值（0-255）
   - 响应：执行成功/失败

2. **停止通道泵**

   - 指定通道号
   - 响应：执行成功/失败

3. **停止所有泵**

   - 紧急停止所有通道的所有泵
   - 响应：执行成功/失败

**执行流程示例**：

```
上位机: "启动通道1液泵1，PWM=153"
下位机: "OK，液泵1已启动，PWM=153"
... (液泵1持续工作) ...
上位机: "停止通道1"
下位机: "OK，通道1已停止"
```

---

#### 4.2 循环模式（Loop Mode）

**工作原理**：

- 分两个阶段：编程阶段 + 执行阶段
- **编程阶段**：发送时序指令，下位机存储到对应通道的时序表
- **执行阶段**：发送执行命令，下位机按两个通道各自存储的时序并行循环执行
- **停止阶段**：发送停止命令，下位机停止执行并清空所有通道的时序表

**重要特性**：
- **双通道独立时序表**：每个通道（CH1、CH2）维护各自独立的时序表和状态机
- **并行执行**：两个通道同时并行执行各自的循环，互不干扰
- **统一控制**：START/STOP/PAUSE/RESUME命令同时控制两个通道

**时序指令结构**：
每条时序指令包含：

- 通道号（CH1/CH2）
- 泵类型（气泵/液泵 1/液泵 2）
- PWM值（0-255）
- 持续时间（毫秒，如 1000ms = 1 秒）

**注意**：每个泵独立配置PWM值，通道本身没有功率值。

**时序表容量**：

- 每个通道最多支持 16 条时序指令
- 两个通道的时序表完全独立
- 可通过查询命令获取每个通道的当前时序表内容

**执行流程示例**：

```
# 编程阶段
上位机: "添加时序指令1: CH1液泵1, PWM=153, 1秒"
下位机: "OK，指令已存储到CH1时序表，位置1"

上位机: "添加时序指令2: CH1液泵2, PWM=204, 2秒"
下位机: "OK，指令已存储到CH1时序表，位置2"

上位机: "添加时序指令3: CH2气泵, PWM=128, 1秒"
下位机: "OK，指令已存储到CH2时序表，位置1"

上位机: "添加时序指令4: CH2液泵1, PWM=180, 1.5秒"
下位机: "OK，指令已存储到CH2时序表，位置2"

# 执行阶段
上位机: "开始循环执行"
下位机: "OK，两个通道开始并行执行各自的循环"

... (下位机并行执行:
     CH1: 液泵1→液泵2→液泵1→液泵2→...
     CH2: 气泵→液泵1→气泵→液泵1→...
    ) ...

上位机: "查询循环状态"
下位机: "CH1正在执行，当前指令1/2，已循环5次
        CH2正在执行，当前指令2/2，已循环5次"

上位机: "停止循环执行"
下位机: "OK，两个通道都已停止执行"
```

**循环模式特殊功能**：

1. **并行执行**：两个通道完全独立，各自按自己的时序表执行
2. **暂停/继续**：同时暂停两个通道的循环，或同时继续
3. **循环次数控制**：
   - 无限循环（默认）
   - 指定循环次数（如循环 10 次后停止）
   - 两个通道使用相同的循环次数参数
4. **循环进度查询**：返回两个通道各自的执行进度和状态

---

#### 4.3 工作模式切换（v1.3更新）

**设计理念**：

系统通过命令**自动触发**模式切换，无需显式的模式切换命令。

**两种工作模式**：

1. **MANUAL模式（指令模式）** - 默认模式
   - 单条命令实时控制泵的启停
   - 可以准备循环时序表
   - 通过 `LOOP_START` 命令自动切换到 LOOP 模式

2. **LOOP模式（循环模式）**
   - 自动执行预定义的时序表
   - 支持双通道独立并行运行
   - 通过 `LOOP_STOP` 命令自动切换回 MANUAL 模式

---

##### 4.3.1 MANUAL模式

**可用命令**：

| 命令 | 功能 | 说明 |
|-----|------|------|
| ✅ SET_PUMP (0x10) | 启动泵 | 立即执行，设置PWM值 |
| ✅ STOP_CHANNEL (0x11) | 停止通道 | 停止指定通道的所有泵 |
| ✅ STOP_ALL (0x12) | 紧急停止 | 停止所有通道的泵 |
| ✅ LOOP_ADD (0x14) | 添加时序 | 向时序表添加指令 |
| ✅ LOOP_CLEAR (0x15) | 清空时序表 | 清空所有通道的时序表 |
| ✅ LOOP_START (0x16) | 启动循环 | ⭐ **自动切换到LOOP模式** |
| ❌ LOOP_STOP (0x17) | 停止循环 | 返回 NACK(0x08) - 无循环可停止 |
| ❌ LOOP_PAUSE (0x18) | 暂停循环 | 返回 NACK(0x08) - 无循环可暂停 |
| ❌ LOOP_RESUME (0x19) | 恢复循环 | 返回 NACK(0x08) - 无循环可恢复 |

**典型使用流程**：

```
1. 手动测试阶段（MANUAL模式）
   发送 SET_PUMP → 测试泵的运行
   发送 STOP_CHANNEL → 停止泵

2. 准备循环阶段（仍在MANUAL模式）
   发送 LOOP_ADD → 添加多条时序指令

3. 启动循环阶段（自动切换到LOOP模式）
   发送 LOOP_START → 系统自动切换到LOOP模式
                     → 开始自动执行时序表
```

---

##### 4.3.2 LOOP模式

**可用命令**：

| 命令 | 功能 | 说明 |
|-----|------|------|
| ❌ SET_PUMP (0x10) | 启动泵 | 返回 NACK(0x08) - 循环模式下禁用 |
| ❌ STOP_CHANNEL (0x11) | 停止通道 | 返回 NACK(0x08) - 循环模式下禁用 |
| ✅ STOP_ALL (0x12) | 紧急停止 | ⭐ **强制切换到MANUAL模式** |
| ✅ LOOP_STOP (0x17) | 停止循环 | ⭐ **自动切换到MANUAL模式** |
| ✅ LOOP_PAUSE (0x18) | 暂停循环 | 暂停执行（保持LOOP模式） |
| ✅ LOOP_RESUME (0x19) | 恢复循环 | 从暂停点继续执行 |
| ✅ LOOP_ADD (0x14) | 添加时序 | 可以继续添加（当前循环完成后生效） |
| ✅ LOOP_CLEAR (0x15) | 清空时序表 | ⚠️  需要先停止循环 |

**典型使用流程**：

```
1. 循环运行中（LOOP模式）
   系统自动执行时序表

2. 暂停循环（可选）
   发送 LOOP_PAUSE → 暂停执行
   发送 LOOP_RESUME → 恢复执行

3. 停止循环（自动切换回MANUAL模式）
   发送 LOOP_STOP → 系统自动切换到MANUAL模式
                  → 清空时序表
                  → 现在可以使用 SET_PUMP 命令
```

---

##### 4.3.3 模式切换触发点

**触发点1：MANUAL → LOOP**

- **触发命令**：`LOOP_START (0x16)`
- **前置条件**：至少有一个通道的时序表不为空
- **切换结果**：
  - `work_mode` 从 `MANUAL` 变为 `LOOP`
  - 循环状态从 `STOPPED` 变为 `RUNNING`
  - 开始自动执行时序表

**触发点2：LOOP → MANUAL**

- **触发命令**：`LOOP_STOP (0x17)`
- **前置条件**：无（任何状态下都可以执行）
- **切换结果**：
  - `work_mode` 从 `LOOP` 变为 `MANUAL`
  - 循环状态变为 `STOPPED`
  - 时序表清空
  - 所有泵停止

---

##### 4.3.4 命令执行权限矩阵

| 命令 | MANUAL模式 | LOOP模式 | 说明 |
|-----|-----------|---------|------|
| **SET_PUMP** | ✅ 允许 | ❌ NACK(0x08) | LOOP模式只能通过时序表控制 |
| **STOP_CHANNEL** | ✅ 允许 | ❌ NACK(0x08) | LOOP模式需用LOOP_STOP |
| **STOP_ALL** | ✅ 允许 | ✅ 允许 → 触发切换 | 紧急停止，**LOOP模式强制切换到MANUAL** |
| **LOOP_ADD** | ✅ 允许 | ✅ 允许 | 两种模式都可添加 |
| **LOOP_CLEAR** | ✅ 允许 | ⚠️  需先停止 | LOOP模式需先发送LOOP_STOP |
| **LOOP_START** | ✅ 允许 → 触发切换 | ✅ 允许 | MANUAL模式触发切换到LOOP |
| **LOOP_STOP** | ❌ NACK(0x08) | ✅ 允许 → 触发切换 | LOOP模式触发切换到MANUAL |
| **LOOP_PAUSE** | ❌ NACK(0x08) | ✅ 允许 | 只在LOOP模式可用 |
| **LOOP_RESUME** | ❌ NACK(0x08) | ✅ 允许 | 只在LOOP模式可用 |
| **GET_STATUS** | ✅ 允许 | ✅ 允许 | 两种模式都可用 |
| **GET_LOOP_STATUS** | ✅ 允许 | ✅ 允许 | 两种模式都可用 |
| **GET_VERSION** | ✅ 允许 | ✅ 允许 | 两种模式都可用 |
| **HEARTBEAT** | ✅ 允许 | ✅ 允许 | 两种模式都可用 |

---

##### 4.3.5 错误码 ERR_MODE_CONFLICT (0x08)

当命令在错误的模式下执行时，返回 `NACK(0x08)`：

**在MANUAL模式下执行**：
- `LOOP_STOP` → NACK(0x08) - 无循环可停止
- `LOOP_PAUSE` → NACK(0x08) - 无循环可暂停
- `LOOP_RESUME` → NACK(0x08) - 无循环可恢复

**在LOOP模式下执行**：
- `SET_PUMP` → NACK(0x08) - 循环模式下禁用手动控制
- `STOP_CHANNEL` → NACK(0x08) - 循环模式下禁用手动控制

**处理方法**：
- 在MANUAL模式下，先使用 `LOOP_START` 切换到LOOP模式
- 在LOOP模式下，先使用 `LOOP_STOP` 切换回MANUAL模式

---

### 5. 心跳保活机制

#### 5.1 心跳规则

**上位机**：

- 每 1 秒发送一次心跳指令
- 心跳指令携带序号（0-255 循环递增）
- 心跳指令携带使能标志（0=关闭检测，1=开启检测）

**下位机**：

- 收到心跳后立即回复，携带序号和当前使能状态
- **当心跳检测使能时**：
  - 如果超过 3 秒没有收到心跳指令：
    - 认为上位机断开连接
    - 立即停止所有泵的工作
    - 进入安全模式
- **当心跳检测关闭时**：
  - 仍然响应心跳包
  - 但不执行超时检测，泵继续运行
  - 用于调试或特殊场景

**上位机超时处理**：

- 如果发送心跳后没有收到响应：
  - 重试 2 次
  - 如果仍然失败，认为下位机断开连接
  - 停止所有操作，提示用户

#### 5.2 心跳数据包

**心跳请求**：

```
帧头 + 命令(0x50) + 长度(2) + 序号(0-255) + 使能标志(0/1) + 校验
```

**心跳响应**：

```
帧头 + 命令(0x50) + 长度(2) + 序号(0-255) + 当前使能状态(0/1) + 校验
```

**字段说明**：
- `序号` (1B): 心跳序号 (0-255)
- `使能标志` (1B): 0=关闭心跳超时检测，1=开启心跳超时检测
- `当前使能状态` (1B): 返回下位机当前的心跳检测使能状态

---

### 6. 功率控制

#### 6.1 功率调节方式

**上位机直接设定PWM值**：
- 通过SET_PUMP命令指定通道、泵类型和PWM值
- PWM值范围：0-255（0=停止，255=满功率）
- 下位机直接使用该PWM值控制对应的泵

**重要说明**：
- 每个泵独立配置PWM值
- 通道本身没有功率或PWM值
- OFFLINE模式下的物理电位器ADC采样仅在脱机工作时有效
- ONLINE模式下完全由上位机通过协议控制

---

### 7. 安全保护

#### 7.1 硬件安全

- 单通道内只有一个泵能工作（硬件互锁）
- 功率调节基于物理开关使能后才生效

#### 7.2 软件安全

- 通讯超时保护（3 秒无心跳自动停机）
- 紧急停止命令（最高优先级）
- 参数范围检查（功率 0-255，时间>0）
- 看门狗保护（1 秒超时自动复位）

#### 7.3 故障处理

- 泵驱动异常时上报错误代码
- 参数错误时返回 NACK + 错误码
- 通讯超时时自动紧急停止所有泵

---

### 8. 错误处理

#### 8.1 错误码定义

| 错误码 | 描述           | 处理建议               |
| ------ | -------------- | ---------------------- |
| 0x01   | CRC 校验错误   | 重新发送命令           |
| 0x02   | 命令不支持     | 检查固件版本           |
| 0x03   | 参数错误       | 检查参数范围           |
| 0x04   | 通道号错误     | 检查通道号是否为 1-2   |
| 0x05   | 泵类型错误     | 检查泵类型是否为 0-2   |
| 0x06   | 硬件故障       | 检查硬件连接           |
| 0x07   | 时序表已满     | 删除部分指令后重试     |
| 0x08   | 模式冲突       | 先停止当前模式再切换   |
| 0x09   | 泵冲突         | 该通道已有泵在运行     |

#### 8.2 错误响应格式

**NACK 响应**：

```
帧头 + 命令(0xFF) + 长度(2) + 原命令码 + 错误码 + 校验
```

---

### 9. 扩展功能（可选）

#### 9.1 时序表管理

- 查询时序表内容
- 删除指定位置的时序指令
- 清空整个时序表
- 保存时序表到 EEPROM（断电保存）

#### 9.2 批量操作

- 批量设置多个通道状态
- 批量读取所有通道状态

#### 9.3 日志功能

- 记录操作日志（最近 N 条）
- 记录错误日志
- 上位机可读取日志

#### 9.4 固件升级

- 通过串口在线升级固件（Bootloader 功能）

---

### 10. 性能要求

| 指标         | 要求    |
| ------------ | ------- |
| 命令响应时间 | < 50ms  |
| 心跳响应时间 | < 10ms  |
| 紧急停止响应 | < 10ms  |
| 功率调节响应 | < 100ms |
| 循环执行精度 | ±50ms   |

---

## 协议实现优先级

### 第一阶段（核心功能）✅

1. ✅ 基本通讯帧格式
2. ✅ 心跳保活机制
3. ✅ 指令模式基础功能（启动/停止/功率设置）
4. ✅ 状态查询
5. ✅ 版本信息获取

### 第二阶段（完整功能）📋

6. 📋 循环模式实现
7. 📋 时序表管理
8. 📋 完整错误处理
9. 📋 安全保护机制

### 第三阶段（扩展功能）🚀

10. 🚀 时序表 EEPROM 保存
11. 🚀 操作日志
12. 🚀 固件升级

## 具体的协议制定和举例

### 1. 数据帧基本格式

#### 1.1 帧结构

```
+--------+--------+--------+--------+----------+--------+
|  BYTE0 |  BYTE1 |  BYTE2 |  BYTE3 |  BYTE4~N | BYTEN+1|
+--------+--------+--------+--------+----------+--------+
|  帧头  |  帧头  |  命令  |  长度  |   数据   |  校验  |
|  0xAA  |  0x55  |  CMD   |  LEN   |   DATA   |  CRC8  |
+--------+--------+--------+--------+----------+--------+
```

**字段说明：**
- **帧头**：固定为 `0xAA 0x55`（2字节）
- **命令**：命令码（1字节），见下表
- **长度**：数据字段长度（1字节），范围 0-255
- **数据**：可变长度，具体格式见各命令定义
- **校验**：CRC8校验值（1字节）

**最小帧长度**：5字节（无数据时）
**最大帧长度**：260字节（数据255字节时）

---

### 2. 命令码定义表

| 命令码 | 名称 | 方向 | 数据长度 | 说明 |
|:-----:|------|:-----:|:--------:|------|
| **下行命令（上位机→下位机）** |
| 0x10 | SET_PUMP | ↓ | 3 | 启动通道泵 |
| 0x11 | STOP_CHANNEL | ↓ | 1 | 停止指定通道 |
| 0x12 | STOP_ALL | ↓ | 0 | 紧急停止所有通道（LOOP模式强制切换到MANUAL）⭐ |
| 0x14 | LOOP_ADD | ↓ | 5 | 添加循环时序指令 |
| 0x15 | LOOP_CLEAR | ↓ | 0 | 清空循环时序表 |
| 0x16 | LOOP_START | ↓ | 1 | 开始循环执行（自动切换到LOOP模式）⭐ |
| 0x17 | LOOP_STOP | ↓ | 0 | 停止循环执行（自动切换到MANUAL模式）⭐ |
| 0x18 | LOOP_PAUSE | ↓ | 0 | 暂停循环执行 |
| 0x19 | LOOP_RESUME | ↓ | 0 | 继续循环执行 |
| ~~0x1A~~ | ~~SET_MODE~~ | ↓ | 1 | ~~设置工作模式~~（v1.3已废弃） |
| 0x20 | GET_VERSION | ↓ | 0 | 获取版本信息 |
| 0x21 | GET_STATUS | ↓ | 1 | 查询运行状态 |
| 0x22 | GET_LOOP_STATUS | ↓ | 0 | 查询循环状态 |
| **上行命令（下位机→上位机）** |
| 0x30 | VERSION_RSP | ↑ | 变长 | 版本信息响应 |
| 0x31 | STATUS_RSP | ↑ | 变长 | 状态查询响应 |
| 0x32 | LOOP_STATUS_RSP | ↑ | 变长 | 循环状态响应 |
| 0x40 | ACK | ↑ | 1 | 确认响应 |
| 0x41 | NACK | ↑ | 2 | 错误响应 |
| **双向命令** |
| 0x50 | HEARTBEAT | ↔ | 2 | 心跳包（序号+使能标志） |

**符号说明：**
- ↓：下行命令（上位机发送给下位机）
- ↑：上行响应（下位机返回给上位机）
- ↔：双向命令

---

### 3. 数据类型定义

#### 3.1 通道号

```c
typedef uint8_t channel_t;
#define CH1   1  // 通道1
#define CH2   2  // 通道2
```

#### 3.2 泵类型

```c
typedef uint8_t pump_type_t;
#define PUMP_AIR       0  // 气泵
#define PUMP_WATER1    1  // 液泵1
#define PUMP_WATER2    2  // 液泵2
```

#### 3.3 工作模式

```c
typedef uint8_t work_mode_t;
#define MODE_MANUAL    0  // 指令模式
#define MODE_LOOP      1  // 循环模式
#define MODE_STOP      2  // 停止模式
```

#### 3.4 循环次数

```c
typedef uint8_t loop_count_t;
#define LOOP_INFINITE  0  // 无限循环
#define LOOP_ONCE      1  // 执行1次
// 其他值表示具体循环次数
```

---

### 4. 详细命令格式

#### 4.1 SET_PUMP (0x10) - 启动通道泵

**功能**：启动指定通道的指定泵，并设置功率

**下行帧格式：**
```
+------+------+-----+-----+-----+-----+-----+
| 0xAA | 0x55 | 0x10| 0x03| CH  | PUMP| PWR | CRC |
+------+------+-----+-----+-----+-----+-----+
```

**数据字段：**
- `CH` (1B): 通道号 (1=CH1, 2=CH2)
- `PUMP` (1B): 泵类型 (0=气泵, 1=液泵1, 2=液泵2)
- `PWR` (1B): PWM值 (0-255)

**响应：**
- 成功：ACK (0x40)
- 失败：NACK (0x41) + 错误码

**示例：启动通道1液泵1，PWM=153**
```
下发: AA 55 10 03 01 01 99 [CRC]
响应: AA 55 40 01 10 [CRC]
```

**注意**：只有泵才有PWM值，通道本身没有功率概念。

---

#### 4.2 STOP_CHANNEL (0x11) - 停止指定通道

**功能**：停止指定通道的所有泵

**下行帧格式：**
```
+------+------+-----+-----+-----+
| 0xAA | 0x55 | 0x11| 0x01| CH  | CRC |
+------+------+-----+-----+-----+
```

**数据字段：**
- `CH` (1B): 通道号 (1=CH1, 2=CH2)

**响应：**
- 成功：ACK (0x40)
- 失败：NACK (0x41) + 错误码

**示例：停止通道1**
```
下发: AA 55 11 01 01 [CRC]
响应: AA 55 40 01 11 [CRC]
```

---

#### 4.3 STOP_ALL (0x12) - 紧急停止所有通道

**功能**：立即停止所有通道的所有泵，最高优先级命令

**⭐ v1.3重要更新**：
- 在 **LOOP 模式**下发送此命令会**强制切换回 MANUAL 模式**
- 停止所有泵的运行
- 停止循环执行
- 清空所有时序表
- 适用于紧急情况下的完全停止

**下行帧格式：**
```
+------+------+-----+-----+
| 0xAA | 0x55 | 0x12| 0x00| CRC |
+------+------+-----+-----+
```

**数据字段：** 无

**响应：**
- 成功：ACK (0x40)
- 响应时间：< 10ms

**示例1：MANUAL模式下紧急停止**
```
初始状态: MANUAL模式
下发: AA 55 12 00 [CRC]
响应: AA 55 40 01 12 [CRC]
结果: 所有泵停止，保持MANUAL模式
```

**示例2：LOOP模式下紧急停止**
```
初始状态: LOOP模式，循环运行中
下发: AA 55 12 00 [CRC]
响应: AA 55 40 01 12 [CRC]
结果: 所有泵停止
      循环状态: RUNNING → STOPPED
      时序表清空
      work_mode: LOOP → MANUAL
```

---

#### 4.4 LOOP_ADD (0x14) - 添加循环时序指令

**功能**：向循环时序表添加一条指令

**下行帧格式：**
```
+------+------+-----+-----+-----+-----+-----+-------+-----+
| 0xAA | 0x55 | 0x14| 0x05| CH  | PUMP| PWR | TIME_H|TIME_L| CRC |
+------+------+-----+-----+-----+-----+-----+-------+-----+
```

**数据字段：**
- `CH` (1B): 通道号 (1=CH1, 2=CH2)
- `PUMP` (1B): 泵类型 (0=气泵, 1=液泵1, 2=液泵2, 255=停止)
- `PWR` (1B): PWM值 (0-255，PUMP=255时忽略)
- `TIME_H` (1B): 时间高字节（毫秒）
- `TIME_L` (1B): 时间低字节（毫秒）
  - 时间 = TIME_H << 8 | TIME_L
  - 单位：毫秒，范围 0-65535ms

**响应：**
- 成功：ACK (0x40)
- 失败：NACK (0x41) + 错误码（0x07=时序表已满）

**示例1：添加指令（CH1液泵1，PWM=153，1秒）**
```
下发: AA 55 14 05 01 01 99 03 E8 [CRC]  // 1000ms = 0x03E8
响应: AA 55 40 01 14 [CRC]
```

**示例2：添加指令（所有泵停止）**
```
下发: AA 55 14 05 01 FF 00 00 00 [CRC]  // PUMP=0xFF表示停止
响应: AA 55 40 01 14 [CRC]
```

---

#### 4.5 LOOP_CLEAR (0x15) - 清空循环时序表

**功能**：清空所有已添加的循环时序指令

**下行帧格式：**
```
+------+------+-----+-----+
| 0xAA | 0x55 | 0x15| 0x00| CRC |
+------+------+-----+-----+
```

**数据字段：** 无

**响应：**
- 成功：ACK (0x40)

**示例：清空时序表**
```
下发: AA 55 15 00 [CRC]
响应: AA 55 40 01 15 [CRC]
```

---

#### 4.6 LOOP_START (0x16) - 开始循环执行

**功能**：开始执行循环时序表中的指令

**⭐ v1.3重要更新**：
- 在 MANUAL 模式下发送此命令会**自动切换到 LOOP 模式**
- 双通道各自独立执行时序表，并行运行
- 如果某个通道时序表为空，则该通道不参与循环

**下行帧格式：**
```
+------+------+-----+-----+-----+
| 0xAA | 0x55 | 0x16| 0x01| CNT | CRC |
+------+------+-----+-----+-----+
```

**数据字段：**
- `CNT` (1B): 循环次数
  - 0 = 无限循环
  - 1-255 = 循环指定次数

**响应：**
- 成功：ACK (0x40) + 系统自动切换到 LOOP 模式
- 失败：NACK (0x41) + 错误码（0x08=时序表为空）

**示例1：在MANUAL模式启动无限循环**
```
初始状态: MANUAL模式
下发: AA 55 16 01 00 [CRC]
响应: AA 55 40 01 16 [CRC]
状态变化: work_mode: MANUAL → LOOP
         循环状态: STOPPED → RUNNING
```

**示例2：循环10次后停止**
```
下发: AA 55 16 01 0A [CRC]  // 0x0A = 10
响应: AA 55 40 01 16 [CRC]
```

---

#### 4.7 LOOP_STOP (0x17) - 停止循环执行

**功能**：停止当前循环执行并清空时序表

**⭐ v1.3重要更新**：
- 在 LOOP 模式下发送此命令会**自动切换回 MANUAL 模式**
- 停止所有通道的循环执行
- 清空所有时序表
- 停止所有泵

**下行帧格式：**
```
+------+------+-----+-----+
| 0xAA | 0x55 | 0x17| 0x00| CRC |
+------+------+-----+-----+
```

**数据字段：** 无

**响应：**
- 成功：ACK (0x40)

**示例：停止循环**
```
下发: AA 55 17 00 [CRC]
响应: AA 55 40 01 17 [CRC]
```

---

#### 4.8 LOOP_PAUSE (0x18) - 暂停循环执行

**功能**：暂停当前循环，保持当前状态

**下行帧格式：**
```
+------+------+-----+-----+
| 0xAA | 0x55 | 0x18| 0x00| CRC |
+------+------+-----+-----+
```

**响应：** ACK (0x40)

---

#### 4.9 LOOP_RESUME (0x19) - 继续循环执行

**功能**：从暂停处继续循环执行

**下行帧格式：**
```
+------+------+-----+-----+
| 0xAA | 0x55 | 0x19| 0x00| CRC |
+------+------+-----+-----+
```

**响应：** ACK (0x40)

---

#### 4.10 ~~SET_MODE (0x1A)~~ - ~~设置工作模式~~（⚠️ v1.3已废弃）

**⚠️ 此命令已在v1.3版本中废弃**

**原因**：
- 系统现在采用**自动模式切换**机制
- 通过 `LOOP_START` 命令自动切换到 LOOP 模式
- 通过 `LOOP_STOP` 命令自动切换到 MANUAL 模式
- 无需显式发送模式切换命令

**替代方案**：
- **MANUAL → LOOP**：发送 `LOOP_START (0x16)` 命令
- **LOOP → MANUAL**：发送 `LOOP_STOP (0x17)` 命令

**详情请参见**：[4.3 工作模式切换](#43-工作模式切换v13更新)

---

#### 4.11 GET_VERSION (0x20) - 获取版本信息

**功能**：获取硬件版本、固件版本、硬件名称

**下行帧格式：**
```
+------+------+-----+-----+
| 0xAA | 0x55 | 0x20| 0x00| CRC |
+------+------+-----+-----+
```

**响应：VERSION_RSP (0x30)**
```
+------+------+-----+-----+-----+-----+-----+-----+-------+-----+
| 0xAA | 0x55 | 0x30| LEN |HW_V |FW_V | NLEN| NAME ...     | CRC |
+------+------+-----+-----+-----+-----+-----+-----+-------+-----+
```

**响应数据字段：**
- `LEN` (1B): 数据长度 = 3 + NLEN
- `HW_V` (1B): 硬件版本（BCD码，0x10 = 1.0）
- `FW_V` (1B): 固件版本（BCD码，0x10 = 1.0）
- `NLEN` (1B): 硬件名称长度
- `NAME` (NLEN B): 硬件名称字符串

**示例：**
```
下发: AA 55 20 00 [CRC]
响应: AA 55 30 0C 10 10 09 66 6C 75 69 64 20 56 30 [CRC]
      解析: LEN=12, HW_V=1.0, FW_V=1.0, NLEN=9, NAME="fluid V0"
```

---

#### 4.12 GET_STATUS (0x21) - 查询运行状态

**功能**：查询当前所有通道的运行状态

**下行帧格式：**
```
+------+------+-----+-----+-----+
| 0xAA | 0x55 | 0x21| 0x01| MASK| CRC |
+------+------+-----+-----+-----+
```

**数据字段：**
- `MASK` (1B): 查询掩码（预留，当前填0）

**响应：STATUS_RSP (0x31)**
```
+------+------++-----+-----+-----+-----+-----+-----+-----+-----+-----+
| 0xAA | 0x55 |0x31 | LEN | MODE| ... 通道数据 ...        | CRC |
+------+------++-----+-----+-----+-----+-----+-----+-----+-----+-----+
```

**响应数据字段：**
- `LEN` (1B): 数据长度
- `MODE` (1B): 当前工作模式 (0=指令, 1=循环, 2=停止)
- **通道数据结构**（每个通道3字节）：
  ```
  +------+------+------+-----+
  |  CH  | PUMP |STATE | PWR |
  +------+------+------+-----+
  | 1B   | 1B   | 1B   | 1B  |
  +------+------+------+-----+
  ```
  - `CH`: 通道号 (1-2)
  - `PUMP`: 当前工作的泵类型 (0=无, 1=气泵, 2=液泵1, 3=液泵2)
  - `STATE`: 运行状态 (0=停止, 1=运行)
  - `PWR`: 该泵的PWM值 (0-255，仅当PUMP!=0时有效)

**重要说明**：
- 只有泵才有PWM值，通道本身没有功率概念
- 当PUMP=0（无泵工作）时，PWR字段无意义
- 各泵的实际PWM值在泵状态结构中体现

**示例：**
```
下发: AA 55 21 01 00 [CRC]
响应: AA 55 31 07 00 01 02 01 99 02 00 00 [CRC]
解析:
  MODE=0 (指令模式)
  CH1: PUMP=2(液泵1), STATE=1(运行), PWR=153
  CH2: PUMP=0(无), STATE=0(停止), PWR=0(无意义)
```

---

#### 4.13 GET_LOOP_STATUS (0x22) - 查询循环状态

**功能**：查询两个通道的循环执行状态

**下行帧格式：**
```
+------+------+-----+-----+
| 0xAA | 0x55 | 0x22| 0x00| CRC |
+------+------+-----+-----+
```

**响应：LOOP_STATUS_RSP (0x32)**
```
+------+------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-------+
| 0xAA | 0x55 | 0x32| LEN |ST1|CU1|TO1|CN1|MX1|ST2|CU2|TO2|CN2|MX2|  CRC  |
+------+------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-------+
```

**响应数据字段：**
- `LEN` (1B): 数据长度 = 10（两个通道各5字节）

**通道1状态（5字节）：**
- `ST1` (1B): 通道1循环状态 (0=停止, 1=运行, 2=暂停)
- `CU1` (1B): 通道1当前执行第几条指令（1-based）
- `TO1` (1B): 通道1总指令数
- `CN1` (1B): 通道1已循环次数
- `MX1` (1B): 最大循环次数（0=无限，两通道相同）

**通道2状态（5字节）：**
- `ST2` (1B): 通道2循环状态 (0=停止, 1=运行, 2=暂停)
- `CU2` (1B): 通道2当前执行第几条指令（1-based）
- `TO2` (1B): 通道2总指令数
- `CN2` (1B): 通道2已循环次数
- `MX2` (1B): 最大循环次数（0=无限，两通道相同）

**示例1：两个通道都在运行**
```
下发: AA 55 22 00 [CRC]
响应: AA 55 32 0A 01 03 04 05 0A 01 02 03 05 0A [CRC]
解析:
  CH1: 运行中, 第3/4条指令, 已循环5次, 共10次
  CH2: 运行中, 第2/3条指令, 已循环5次, 共10次
```

**示例2：通道1运行，通道2停止**
```
下发: AA 55 22 00 [CRC]
响应: AA 55 32 0A 01 02 03 05 00 00 00 00 00 00 [CRC]
解析:
  CH1: 运行中, 第2/3条指令, 已循环5次, 无限循环
  CH2: 已停止, 无指令
```

**示例3：两个通道都暂停**
```
下发: AA 55 22 00 [CRC]
响应: AA 55 32 0A 02 01 02 03 00 02 02 04 03 00 [CRC]
解析:
  CH1: 暂停中, 第1/2条指令, 已循环3次, 无限循环
  CH2: 暂停中, 第2/4条指令, 已循环3次, 无限循环
```

---

#### 4.14 HEARTBEAT (0x50) - 心跳包

**功能**：保持连接活性，检测连接状态，控制心跳超时检测

**双向格式：**
```
+------+------+-----+-----+-----+-------+
| 0xAA | 0x55 | 0x50| 0x02| SEQ | ENABLE| CRC |
+------+------+-----+-----+-----+-------+
```

**数据字段：**
- `SEQ` (1B): 序列号 (0-255，循环递增)
- `ENABLE` (1B): 心跳检测使能标志
  - 下行：0=关闭超时检测，1=开启超时检测
  - 上行：返回当前实际的使能状态

**响应：** 相同心跳包（立即回复），序号相同，使能状态为当前实际状态

**示例1：开启心跳检测**
```
上位机: AA 55 50 02 01 01 [CRC]  // 序号1，开启检测
下位机: AA 55 50 02 01 01 [CRC]  // 立即回复序号1，当前已开启检测
```

**示例2：关闭心跳检测**
```
上位机: AA 55 50 02 02 00 [CRC]  // 序号2，关闭检测
下位机: AA 55 50 02 02 00 [CRC]  // 立即回复序号2，当前已关闭检测
```

**说明**：
- 开启检测时：3秒无心跳自动停机
- 关闭检测时：仅响应心跳，不执行超时停机，用于调试场景

---

#### 4.15 ACK (0x40) - 确认响应

**功能**：命令执行成功

**上行帧格式：**
```
+------+------+-----+-----+-----+
| 0xAA | 0x55 | 0x40| 0x01| CMD | CRC |
+------+------+-----+-----+-----+
```

**数据字段：**
- `CMD` (1B): 被确认的命令码

---

#### 4.16 NACK (0x41) - 错误响应

**功能**：命令执行失败

**上行帧格式：**
```
+------+------+-----+-----+-----+-----+
| 0xAA | 0x55 | 0x41| 0x02| CMD | ERR | CRC |
+------+------+-----+-----+-----+-----+
```

**数据字段：**
- `CMD` (1B): 出错的命令码
- `ERR` (1B): 错误码 (见错误码定义表)

**示例：**
```
下发: AA 55 10 03 03 01 99 [CRC]  // 错误：通道号3不存在
响应: AA 55 41 02 10 04 [CRC]     // 错误码0x04：通道号错误
```

---

### 5. CRC8 校验算法

#### 5.1 算法参数

- **多项式**：0x07 (x^8 + x^2 + x + 1)
- **初始值**：0x00
- **输入反转**：无
- **输出反转**：无
- **异或输出**：0x00

#### 5.2 C语言实现

```c
/**
 * 计算CRC8校验值
 * @param data 数据缓冲区
 * @param len 数据长度（从命令字段开始）
 * @return CRC8校验值
 */
uint8_t calc_crc8(const uint8_t *data, uint8_t len) {
    uint8_t crc = 0x00;

    for (uint8_t i = 0; i < len; i++) {
        crc ^= data[i];
        for (uint8_t j = 0; j < 8; j++) {
            if (crc & 0x80) {
                crc = (crc << 1) ^ 0x07;
            } else {
                crc <<= 1;
            }
        }
    }

    return crc;
}

/**
 * 构建完整的数据帧
 * @param cmd 命令码
 * @param data 数据缓冲区
 * @param len 数据长度
 * @param out_frame 输出帧缓冲区
 * @return 帧总长度
 */
uint8_t build_frame(uint8_t cmd, const uint8_t *data, uint8_t len, uint8_t *out_frame) {
    uint8_t index = 0;

    // 帧头
    out_frame[index++] = 0xAA;
    out_frame[index++] = 0x55;

    // 命令和长度
    out_frame[index++] = cmd;
    out_frame[index++] = len;

    // 数据
    if (len > 0 && data != NULL) {
        memcpy(&out_frame[index], data, len);
        index += len;
    }

    // 计算CRC（校验范围：命令 + 长度 + 数据）
    uint8_t crc = calc_crc8(&out_frame[2], 2 + len);
    out_frame[index++] = crc;

    return index;  // 返回帧总长度
}

/**
 * 验证帧的CRC
 * @param frame 接收到的帧
 * @param frame_len 帧长度
 * @return true=CRC正确, false=CRC错误
 */
bool verify_frame(const uint8_t *frame, uint8_t frame_len) {
    if (frame_len < 5) return false;  // 最小帧长度检查

    uint8_t cmd = frame[2];
    uint8_t len = frame[3];
    uint8_t crc_recv = frame[4 + len];

    uint8_t crc_calc = calc_crc8(&frame[2], 2 + len);

    return (crc_calc == crc_recv);
}
```

#### 5.3 Python实现

```python
def calc_crc8(data: bytes) -> int:
    """
    计算CRC8校验值
    :param data: 数据字节（从命令字段开始）
    :return: CRC8校验值
    """
    crc = 0x00
    for byte in data:
        crc ^= byte
        for _ in range(8):
            if crc & 0x80:
                crc = (crc << 1) ^ 0x07
            else:
                crc <<= 1
            crc &= 0xFF
    return crc

def build_frame(cmd: int, data: bytes = b'') -> bytes:
    """
    构建完整的数据帧
    :param cmd: 命令码
    :param data: 数据字段
    :return: 完整帧
    """
    frame = bytearray()
    frame.append(0xAA)  # 帧头
    frame.append(0x55)  # 帧头
    frame.append(cmd)   # 命令
    frame.append(len(data))  # 长度
    frame.extend(data)  # 数据

    # 计算CRC
    crc_data = bytes([cmd, len(data)]) + data
    crc = calc_crc8(crc_data)
    frame.append(crc)

    return bytes(frame)

# 示例：构建启动通道1液泵1的命令
frame = build_frame(0x10, bytes([0x01, 0x01, 0x99]))
print(' '.join([f'{b:02X}' for b in frame]))  # AA 55 10 03 01 01 99 XX
```

---

### 6. 完整通信示例

#### 6.1 场景1：指令模式启动泵

**操作：启动通道1液泵1，PWM=153**

```
上位机 → 下位机: AA 55 10 03 01 01 99 B0
                    ↓ 帧头  ↓命令  ↓长度  ↓数据   ↓CRC
下位机 → 上位机: AA 55 40 01 10 8C
                    ↓帧头  ↓ACK   ↓命令   ↓CRC
```

**数据解析：**
- 下发：CH=1, PUMP=1(液泵1), PWR=153(0x99)
- 响应：命令0x10执行成功

**注意**：直接指定泵的PWM值，通道本身没有功率概念。

---

#### 6.2 场景2：查询状态

**操作：查询当前运行状态**

```
上位机 → 下位机: AA 55 21 01 00 8D
下位机 → 上位机: AA 55 31 07 00 01 02 01 99 02 00 00 E5
```

**响应数据解析：**
```
31   - 响应命令
07   - 数据长度7字节
00   - 工作模式：指令模式

【通道1】
01   - 通道号
02   - 泵类型：液泵1
01   - 状态：运行
99   - PWM：153

【通道2】
02   - 通道号
00   - 泵类型：无
00   - 状态：停止
00   - PWM：0（无意义，因为无泵工作）
```

**注意**：响应数据已移除ADC字段，只有泵才有PWM值。

---

#### 6.3 场景3：循环模式（双通道并行执行）

**操作：配置并执行双通道并行循环**
- CH1: 液泵1(1秒) → 液泵2(2秒) → 停止，循环10次
- CH2: 气泵(1秒) → 液泵1(1.5秒)，循环10次

```
# 步骤1：添加CH1时序指令
上位机 → 下位机: AA 55 14 05 01 01 99 03 E8 B0  // CH1液泵1, PWM=153, 1000ms
下位机 → 上位机: AA 55 40 01 14 9C

上位机 → 下位机: AA 55 14 05 01 02 CC 07 D0 C7  // CH1液泵2, PWM=204, 2000ms
下位机 → 上位机: AA 55 40 01 14 9C

上位机 → 下位机: AA 55 14 05 01 FF 00 00 00 48  // CH1停止
下位机 → 上位机: AA 55 40 01 14 9C

# 步骤2：添加CH2时序指令
上位机 → 下位机: AA 55 14 05 02 00 80 03 E8 D1  // CH2气泵, PWM=128, 1000ms
下位机 → 上位机: AA 55 40 01 14 9C

上位机 → 下位机: AA 55 14 05 02 01 B4 05 DC 1B  // CH2液泵1, PWM=180, 1500ms
下位机 → 上位机: AA 55 40 01 14 9C

# 步骤3：开始循环（10次，两个通道同时启动）
上位机 → 下位机: AA 55 16 01 0A 7D
下位机 → 上位机: AA 55 40 01 16 A0

# 步骤4：查询循环状态
上位机 → 下位机: AA 55 22 00 93
下位机 → 上位机: AA 55 32 0A 01 02 03 05 0A 01 01 02 05 0A 69
                    ↓CH1:运行↓第2条↓共3条↓5次↓10次 ↓CH2:运行↓第1条↓共2条↓5次↓10次

# 步骤5：停止循环（两个通道同时停止）
上位机 → 下位机: AA 55 17 00 90
下位机 → 上位机: AA 55 40 01 17 A1
```

**执行时序说明：**
```
时间轴：
T=0s:   CH1执行液泵1(1s)  CH2执行气泵(1s)
T=1s:   CH1执行液泵2(2s)  CH2执行液泵1(1.5s)
T=2.5s: CH1继续液泵2      CH2完成第1轮，回到气泵
T=3s:   CH1完成第1轮，回到液泵1  CH2执行气泵
T=3.5s: CH1执行液泵1      CH2执行液泵1
T=4.5s: CH1执行液泵2      CH2完成第2轮，回到气泵
...
```

**关键特性：**
- 两个通道完全独立，各自按自己的时序表执行
- 一个通道的某个步骤完成时，只有该通道进入下一步骤
- 查询状态时，可以分别看到两个通道的执行进度

---

#### 6.4 场景4：错误处理

**操作：尝试启动不存在的通道3**

```
上位机 → 下位机: AA 55 10 03 03 01 99 D1
下位机 → 上位机: AA 55 41 02 10 04 94
                    ↓NACK  ↓原命令 ↓错误码0x04
```

**错误解析：**
- 错误码0x04：通道号错误（有效范围为1-2）

---

#### 6.5 场景5：心跳保活

**正常心跳流程（开启检测）：**
```
T=0ms:   上位机 → 下位机: AA 55 50 02 01 01 35  // 序号1，开启检测
         下位机 → 上位机: AA 55 50 02 01 01 35  (<10ms响应)

T=1000ms: 上位机 → 下位机: AA 55 50 02 02 01 3E  // 序号2，保持检测
         下位机 → 上位机: AA 55 50 02 02 01 3E

T=2000ms: 上位机 → 下位机: AA 55 50 02 03 01 23  // 序号3，保持检测
         下位机 → 上位机: AA 55 50 02 03 01 23
```

**关闭心跳检测：**
```
T=3000ms: 上位机 → 下位机: AA 55 50 02 04 00 2C  // 序号4，关闭检测
         下位机 → 上位机: AA 55 50 02 04 00 2C  // 确认已关闭

// 之后即使无心跳，泵也不会自动停止，用于调试场景
```

**下位机超时处理（仅当检测开启时）：**
```
T=0ms:   收到心跳，重置超时计数器
T=1000ms: 收到心跳，重置超时计数器
T=2000ms: 收到心跳，重置超时计数器
T=3000ms: 超过3秒未收到心跳
         → 立即停止所有泵
         → 进入安全模式
         → 等待重新连接
```

**上位机超时重试：**
```
T=3000ms: 上位机 → 下位机: AA 55 50 02 05 01 2E  // 序号5
         (无响应，上位机重试)

T=3050ms: 上位机 → 下位机: AA 55 50 02 05 01 2E  (重试1)
         (无响应)

T=3100ms: 上位机 → 下位机: AA 55 50 02 05 01 2E  (重试2)
         (无响应)

T=3100ms: 上位机判断下位机断开连接，停止所有操作并提示用户
```

---

### 7. 状态机定义

#### 7.1 下位机主状态机

```
               初始化
                  ↓
            ┌─────────┐
            │  IDLE   │ 空闲状态
            └────┬────┘
                 │ 心跳正常/命令到来
                 ↓
         ┌───────┴───────┐
         │               │
    ┌────↓────┐     ┌────↓────┐
    │ MANUAL  │     │  LOOP   │
    │ 指令模式 │     │ 循环模式 │
    └────┬────┘     └────┬────┘
         │               │
         │ STOP_ALL      │ LOOP_STOP
         └───────┬───────┘
                 ↓
            ┌─────────┐
            │  ERROR  │ 错误状态
            └────┬────┘
                 │
                 ↓ 看门狗复位
              重新初始化
```

#### 7.2 通道状态机

```
         ┌──────────┐
         │   STOP   │ 停止状态
         └────┬─────┘
              │ SET_PUMP
              ↓
         ┌──────────┐
         │ RUNNING  │ 运行状态
         └────┬─────┘
              │ STOP_CHANNEL / STOP_ALL
              ↓
         ┌──────────┐
         │   STOP   │
         └──────────┘
```

---

### 8. 时序要求

#### 8.1 响应时间要求

| 操作类型 | 最大响应时间 | 说明 |
|---------|------------|------|
| 心跳响应 | 10ms | 立即回复 |
| 紧急停止 | 10ms | 最高优先级 |
| 命令处理 | 50ms | 普通命令 |
| 循环切换精度 | ±50ms | 时序指令切换 |
| 功率调节 | 100ms | ADC采样+PWM更新 |

#### 8.2 通讯时序

```
上位机                              下位机
  |                                    |
  |----------- 命令帧 ---------------->|
  |           (T1)                     |
  |                                    |-- [处理命令]
  |                                    |
  |<-------- ACK/NACK -----------------|
  |           (T2)                     |
  |                                    |
  |  T2 - T1 < 50ms                    |
```

---

### 9. 附录

#### 9.1 BCD码转换

版本号使用BCD编码：
- 1.0 → 0x10
- 1.5 → 0x15
- 2.0 → 0x20

```c
// 版本号转BCD
uint8_t version_to_bcd(float ver) {
    uint8_t major = (uint8_t)ver;
    uint8_t minor = (uint8_t)((ver - major) * 10);
    return (major << 4) | minor;
}

// BCD转版本号
float bcd_to_version(uint8_t bcd) {
    uint8_t major = (bcd >> 4) & 0x0F;
    uint8_t minor = bcd & 0x0F;
    return major + minor / 10.0;
}
```

#### 9.2 16位数据大小端处理

时间、ADC等16位数据采用**大端模式**（高字节在前）：

```c
// 打包16位数据（大端）
void pack_u16_be(uint8_t *buf, uint16_t value) {
    buf[0] = (value >> 8) & 0xFF;  // 高字节
    buf[1] = value & 0xFF;          // 低字节
}

// 解包16位数据（大端）
uint16_t unpack_u16_be(const uint8_t *buf) {
    return ((uint16_t)buf[0] << 8) | buf[1];
}
```

---

### 10. 实现建议

#### 10.1 下位机（Arduino）实现要点

1. **使用环形缓冲区**接收串口数据，避免丢包
2. **CRC校验优先**，收到帧立即校验
3. **命令处理超时保护**，避免死锁
4. **看门狗必须启用**，提高系统可靠性
5. **PWM更新在主循环**，避免中断中耗时操作

#### 10.2 上位机实现要点

1. **心跳独立线程**，确保定时发送
2. **命令队列管理**，避免并发冲突
3. **超时重传机制**，提高可靠性
4. **日志记录**，方便调试和故障排查
5. **CRC库验证**，确保算法一致性

#### 10.3 调试技巧

1. **串口抓包工具**：RealTerm、CoolTerm
2. **日志格式**：`[TX/RX] AA 55 10 04 01 01 3C D2`
3. **LED指示**：心跳灯、错误灯
4. **单元测试**：先测试CRC，再测试通讯

---

**协议版本：** 1.3
**最后更新：** 2025-01-15
**维护者：** 液动工具包项目组

**版本历史：**
- v1.3 (2025-01-15):
  - **重构循环模式** - 双通道独立时序表和状态机，并行执行
  - **GET_LOOP_STATUS返回双通道状态** - 每个通道5字节，共10字节
  - ⭐ **自动模式切换机制** - 废除SET_MODE命令，通过LOOP_START/LOOP_STOP自动切换MANUAL/LOOP模式
  - **命令权限控制** - 不同模式下命令执行权限不同，错误模式返回NACK(0x08)
- v1.2 (2025-01-14): 心跳包增加使能标志，支持关闭心跳超时检测
- v1.1 (2025-01-14): 移除ADC相关字段，移除SET_POWER和GET_POWER命令，明确只有泵才有PWM值
- v1.0 (2025-01-12): 初始版本
